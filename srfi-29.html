<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <title>SRFI 29: Localization</title>
                                                                        
   
  <meta name="author" content="Scott G. Miller">
                                           
  <meta name="description" content="Localization">
</head>
  <body>
                        
<H1>Title</H1>
           Localization             
<H1>Author</H1>
           Scott G. Miller             
<H1>Abstract</H1>
           This document specifies an interface to retrieving and displaying
  locale    sensitive messages. &nbsp;An Scheme program can <br>
           register one or more translations of templated messages, and then
  write    Scheme code that can transparently retrieve the appropriate message
  for  the  locale under which the Scheme system is running.&nbsp; <br>
             
<h1>Rationale<br>
           </h1>
           As any programmer that has ever had to deal with making his or 
her   code   readable in more than one locale, the process of sufficiently 
abstracting     program messages from their presentation to the user. &nbsp;Most 
modern   programming  language libraries provide some mechanism for performing 
this   separation.  &nbsp;<br>
           <br>
           A portable API that allows a piece of code to run without modification 
    in  different countries and under different languages is a must for any 
  non-trivial   software project. &nbsp;The interface should separate the 
logic  of a program   from the myriad of translations that may be necessary. 
&nbsp;<br>
           <br>
           The interface described in this document provides such functionality.
    &nbsp;The  underlying implementation is also allowed to use whatever
datastructures     it likes to provide access to the translations in the
most efficient manner     possible.<br>
          <br>
          This interface <i>does not</i> cover all aspects of localization, 
 including    support for non-latin characters, number and date formatting, 
 etc. Such  functionality  is the scope of a future SRFI that may extend this
 one.<br>
                     
<h1>Dependencies</h1>
      An SRFI 29-conformant implementation must also implement SRFI-28, Basic 
  Format Strings. &nbsp;Message template's are strings that must be processed 
  by the <tt>format</tt> function specified in that SRFI.<br>
           
<h1>Specification</h1>
                     
<h3>Message Bundles</h3>
           A Message Bundle is a set of message templates and their identifying 
   keys.   &nbsp;Each bundle contains one or more such key/value pairs. The 
  bundle itself  is associated with a <i>locale specifier </i>which uniquely 
  identifies the  bundle. &nbsp;<br>
                        
<h3>Bundle Specifiers</h3>
           A Bundle Specifier is a Scheme list that describes, in order of
 importance,     the package and locale of a message bundle. &nbsp;In most
 cases, a locale     specifier will have between one and three elements.
&nbsp;The  first element     is a symbol denoting the package for which this
bundle applies. &nbsp;The     second and third elements denote a <i>locale.
&nbsp;</i> The second element     (first element of the locale) if present,
is the two letter language code     for the bundle. &nbsp; The third element,
if present, is a two letter country    code. &nbsp;All bundle specifier elements
are Scheme symbols.<br>
           <br>
           If only one translation is provided, it should be designated only
  by  a  package  name, for example <tt>(mathlib). </tt>This translation
is   called   the <i>default  </i>translation.<br>
                     
<h3>Bundle Searching</h3>
           When a message template is retrieved from a bundle, the Scheme 
implementation      will provide the locale under which the system is currently 
running. &nbsp;When     the template is retrieved, the package name will be
specified. &nbsp;The    Scheme system should construct a Bundle Specifier 
from the provided package    name and the active locale. &nbsp;For example, 
when retrieving a message   template for French Canadian, in the <tt>mathlib 
</tt>package, the bundle   specifier '<tt>(mathlib fr ca)</tt>' is used. &nbsp;A
program may also retrieve   the current locale (as a two-element list) using
the no-argument procedure:<br>
           <br>
           <b><tt>current-locale </tt></b><tt>-&gt; <i>list</i></tt><b><br>
           </b>           
<blockquote>returns the current locale as a two element list. &nbsp;The first 
     element is the current-locale's language code. &nbsp;The second is the 
  locale's   country code. &nbsp;Both are symbols.<br>
             </blockquote>
             <br>
           The Scheme System should first check for a bundle with the exact 
 name   provided.  &nbsp;If no such bundle is found, the last element from 
 the list   is removed  and a search is tried for a bundle with that name. 
 &nbsp;If no  bundle is then found, the list is shortened by removing the 
last element  again. &nbsp;If  &nbsp;no message is found and the bundle specifier 
 is now  the empty list,  an error should be raised.<br>
             <br>
           The reason for this search order is to provide the most locale 
senstive     template possible, but to fall back on more general templates 
if a translation     has not yet been provided for the given locale.<br>
             <br>
                                           
<h3>Message Templates</h3>
           A message template is a localized message that may or may not
contain     one  of a number of formatting codes. &nbsp;A message template
is a Scheme     string.  &nbsp;The string is of a form that can be processed
by the <tt>      format</tt>      procedure found in many Scheme systems
and formally  specified   in SRFI-28   (Basic Format Strings)     <br>
                                             
<h3>Declaring Bundles</h3>
               <b><tt>declare-bundle</tt></b><tt> <i>bundle-specifier association-list 
         </i>-&gt; undefined<br>
               </tt>                                   
<blockquote>Declares a new bundle named by the given bundle-specifier. &nbsp;The
contents of the bundle are defined by the provided association list. &nbsp;The
list contains associations between Scheme symbols and the message templates
(Scheme strings) they name. &nbsp;If a bundle already exists with the given
name, it is overwritten with the newly declared bundle.<br>
                 </blockquote>
                                                                   
<h3>Retrieving Localized Message Templates</h3>
                 <b><tt>localized-template </tt></b><i><tt>package-name message-template-name 
           </tt></i><tt>-&gt; <i>string or #f<br>
                 </i></tt>                                              
          
<blockquote>Retrieves a localized message template for the given package 
    name and the given message template name (both symbols). &nbsp;If no such
    message could be found, false (#f) is returned.<br>
                   <br>
                   </blockquote>
           After retrieving a template, the calling program can use <tt>format</tt>
           to produce a string that can be displayed to the user.<br>
                                                                         
     
<h1>Examples<br>
               </h1>
                                                                   
<pre>(declare-bundle<br> '(hello-program en)<br> '((hello . "Hello, ~a!")<br>   (goodbye . "Goodbye, ~a.")))<br><br>(declare-bundle<br> '(hello-program fr)<br> '((hello . "Salut, ~a!")<br>   (goodbye . "Au revoir, ~a.")))<br><br>(define localized-message<br>  (lambda (message-name . args)<br>    (apply format (cons (localized-template 'hello-program message-name)<br>			args))))<br><br>(let ((myname "Fred"))<br>  (display (localized-message 'hello myname))<br>  (display #\newline)<br>  <br>  (display (localized-message 'goodbye myname))<br>  (display #\newline))<br><br></pre>
                                                                        
<h1>Implementation</h1>
                   The implementation that the Scheme implementation    provide
  a definition for <tt>current-locale </tt>capable of distinguishing    the
  locale present during a Scheme session. &nbsp;The definition of <tt>  
 current-locale</tt>      in the reference implementation is provided only
so that the following  code can run in any R4RS scheme system. <br>
                <br>
                                                           
<pre>;; The association list in which bundles will be stored<br>(define *localization-bundles* '())<br><br>;; The current-locale function provided here must be rewritten<br>;; for each Scheme system to return the actual locale of the<br>;; session<br>(define current-locale<br>  (lambda ()<br>    '(en US)))<br><br><br>;; Declare a bundle of templates with a given bundle specifier<br>(define declare-bundle<br>  (letrec ((remove-old-bundle<br>	    (lambda (specifier bundle)<br>	      (cond ((null? bundle) '())<br>		    ((equal? (caar bundle) specifier)<br>		     (cdr bundle))<br>		    (else (cons (car bundle)<br>				(remove-old-bundle specifier<br>						   (cdr bundle))))))))<br>  (lambda (bundle-specifier bundle-assoc-list)<br>    (set! *localization-bundles*<br>	  (cons (cons bundle-specifier bundle-assoc-list)<br>		(remove-old-bundle bundle-specifier<br>				   *localization-bundles*))))))<br><br>;;Retrieve a localized template given its package name and a template name<br>(define localized-template<br>  (letrec ((rdc<br>	    (lambda (ls)<br>	      (if (null? (cdr ls))<br>		  '()<br>		  (cons (car ls) (rdc (cdr ls))))))<br>	   (find-bundle<br>	    (lambda (specifier template-name)<br>	      (let ((bundle<br>		     (assoc specifier *localization-bundles*)))<br>		(cond (bundle bundle)<br>		      ((null? specifier) #f)<br>		      (else (find-bundle (rdc specifier)<br>					 template-name)))))))<br>  (lambda (package-name template-name)<br>    (let loop ((specifier (cons package-name (current-locale))))<br>      (if (null? specifier)<br>	  #f<br>	  (let ((bundle (find-bundle specifier template-name)))<br>	    (if bundle<br>		(let ((template (assq template-name bundle)))<br>		  (cond (template (cdr template))<br>			((null? (cdr specifier)) #f)<br>			(else (loop (rdc specifier)))))<br>		#f)))))))<br></pre>
                                       
<h1>Copyright</h1>
            Copyright (C) Scott G. Miller (2002). All Rights Reserved.  
                                                                        
     
<p> This document and translations of it may be copied and furnished    
 to others, and derivative works that comment on or otherwise explain it
  or  assist in its implementation may be prepared, copied, published and
distributed,    in whole or in part, without restriction of any kind, provided
that the  above  copyright notice and this paragraph are included on all
such copies  and derivative  works. However, this document itself may not
be modified in any way, such  as by removing the copyright notice or references
to the Scheme Request For  Implementation process or editors, except as needed
for the purpose of developing  SRFIs in which case the procedures for copyrights
 defined in the SRFI process  must be followed, or as required to translate
 it into languages other than  English. </p>
                                                                        
               
<p> The limited permissions granted above are perpetual and will not    
 be revoked by the authors or their successors or assigns. </p>
                                                                        
               
<p> This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL WARRANTIES, 
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE 
  USE   OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED 
  WARRANTIES   OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.   
   </p>
                                                                        
               
<hr>                                                                    
              
<address>Editor:&nbsp;</address>
 <!-- Created: Tue Sep 29 19:20:08 EDT 1998 --><!-- hhmts start --><!-- hhmts end -->
                      Last  modified: Fri Mar 8 17:43:25 PDT 2002       
                                                                        
  
</body>
</html>
