<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI 29: Localization</title>
    <meta name="author" content="Scott G. Miller">
    <meta name="description" content="Localization">
  </head>
  <body>
    <H1>Title</H1>
    Localization             
    <H1>Author</H1>
    Scott G. Miller             
    <h1>Abstract</h1>
    This document specifies an interface to retrieving and displaying
    locale sensitive messages.  A Scheme program can 
    register one or more translations of templated messages, and then
    write Scheme code that can transparently retrieve the appropriate message
    for the locale under which the Scheme system is running.
    <br>
    <h1>Rationale</h1>
    <p>
      As any programmer that has ever had to deal with making his or 
      her   code  readable in more than one locale, the process of sufficiently 
      abstracting program messages from their presentation to the user
      is non-trivial without help from the programming language.  Most 
      modern programming language libraries do provide some mechanism
      for performing this separation.  
    <p>
      A portable API that allows a piece of code to run without modification 
      in  different countries and under different languages is a must for any 
      non-trivial   software project.  The interface should separate the 
      logic  of a program   from the myriad of translations that may be
      necessary. 
    <p>
      The interface described in this document provides such functionality.
      The underlying implementation is also allowed to use whatever
      datastructures it likes to provide access to the translations in the
      most efficient manner possible.
    <p>
      This interface <i>does not</i> cover all aspects of localization, 
      including support for non-latin characters, number and date formatting, 
      etc.  Such functionality is the scope of a future SRFI that may 
      extend this one. 
      
    <h1>Dependencies</h1>
    An SRFI 29-conformant implementation must also implement SRFI-28, Basic 
    Format Strings.  Message templates are strings that must be processed 
    by the <tt>format</tt> function specified in that SRFI.
    
    <h1>Specification</h1>
    
    <h3>Message Bundles</h3>
    <p>
      A Message Bundle is a set of message templates and their identifying 
      keys.  Each bundle contains one or more such key/value pairs.  The 
      bundle itself  is associated with a <i>bundle specifier</i> which 
      uniquely identifies the bundle.
    
    <h3>Bundle Specifiers</h3>
    <p>
      A Bundle Specifier is a Scheme list that describes, in order of
      importance, the package and locale of a message bundle.  In most
      cases, a locale specifier will have between one and three elements.
      The  first element is a symbol denoting the package for which this
      bundle applies.  The second and third elements denote a <i>locale</i>.
      The second element (first element of the locale) if present,
      is the two letter language code for the bundle.  The third element,
      if present, is a two letter country code.  All bundle specifier elements
      are Scheme symbols.
    <p>
      If only one translation is provided, it should be designated only
      by a package name, for example <tt>(mathlib)</tt>.  This translation
      is called the <i>default</i> translation.
                     
    <h3>Bundle Searching</h3>
    <p>
      When a message template is retrieved from a bundle, the Scheme 
      implementation will provide the locale under which the system is 
      currently running.  When the template is retrieved, the package 
      name will be specified.  The Scheme system should construct a
      Bundle Specifier from the provided package name and the active
      locale.  For example, when retrieving a message  template for
      French Canadian, in the <tt>mathlib</tt> package, the bundle
      specifier '<tt>(mathlib fr ca)</tt>' is used.  A program may
      also retrieve the current locale (as a two-element list) using
      the no-argument procedure:
    <p>
      <b><tt>current-locale </tt></b><tt>-&gt; <i>list</i></tt><b><br>
      </b>           
    <blockquote>returns the current locale as a two element list.  The first 
      element is the current-locale's language code.  The second is the 
      locale's   country code.  Both are symbols.<br>
    </blockquote>
    <p>
      The Scheme System should first check for a bundle with the exact 
      name   provided.  If no such bundle is found, the last element from 
      the list is removed and a search is tried for a bundle with that name.  
      If no bundle is then found, the list is shortened by removing the 
      last element again.  If no message is found and the bundle specifier 
      is now the empty list, an error should be raised.
    <p>
      The reason for this search order is to provide the most locale 
      senstive template possible, but to fall back on more general templates 
      if a translation   has not yet been provided for the given
      locale.
                                           
    <h3>Message Templates</h3>
    <p>
      A message template is a localized message that may or may not
      contain one of a number of formatting codes.  A message template
      is a Scheme string.  The string is of a form that can be processed
      by the <tt>format</tt>  procedure found in many Scheme systems
      and formally specified in SRFI-28   (Basic Format Strings)     
    
      
    <h3>Declaring Bundles</h3>
    <p>
      <b><tt>declare-bundle</tt></b><tt> <i>bundle-specifier association-list 
        </i>-&gt; undefined<br>
      </tt>                                   
    <blockquote>Declares a new bundle named by the given bundle-specifier.  The
      contents of the bundle are defined by the provided association list.  The
      list contains associations between Scheme symbols and the message templates
      (Scheme strings) they name.  If a bundle already exists with the given
      name, it is overwritten with the newly declared bundle.
    </blockquote>
                                                                   
    <h3>Retrieving Localized Message Templates</h3>
    <p>
      <b><tt>localized-template </tt></b><i><tt>package-name message-template-name 
        </tt></i><tt>-&gt; <i>string or #f<br>
        </i></tt>                                              
      
    <blockquote>Retrieves a localized message template for the given package 
      name and the given message template name (both symbols).  If no such
      message could be found, false (#f) is returned.<br>
      <br>
    </blockquote>
    After retrieving a template, the calling program can use <tt>format</tt>
    to produce a string that can be displayed to the user.<br>
    
    
    <h1>Examples</h1>
    <p>
                                                                   
    <pre>
(declare-bundle
 '(hello-program en)
 '((hello . "Hello, ~a!")
   (goodbye . "Goodbye, ~a.")))

(declare-bundle
 '(hello-program fr)
 '((hello . "Salut, ~a!")
   (goodbye . "Au revoir, ~a.")))

(define localized-message
  (lambda (message-name . args)
    (apply format (cons (localized-template 'hello-program
  message-name)
                        args))))

(let ((myname "Fred"))
  (display (localized-message 'hello myname))
  (display #\newline)
  
  (display (localized-message 'goodbye myname))
  (display #\newline))
    </pre>
                                                                        
    <h1>Implementation</h1>
    <p>
      The implementation that the Scheme implementation  provide
      a definition for <tt>current-locale </tt>capable of distinguishing the
      locale present during a Scheme session.  The definition of 
      <tt>current-locale</tt> in the reference implementation is provided only
      so that the following  code can run in any R4RS scheme system. 
    <p>
    <pre>
;; The association list in which bundles will be stored
(define *localization-bundles* '())

;; The current-locale function provided here must be rewritten
;; for each Scheme system to return the actual locale of the
;; session
(define current-locale
  (lambda ()
    '(en US)))


;; Declare a bundle of templates with a given bundle specifier
(define declare-bundle
  (letrec ((remove-old-bundle
            (lambda (specifier bundle)
              (cond ((null? bundle) '())
                    ((equal? (caar bundle) specifier)
                     (cdr bundle))
                    (else (cons (car bundle)
                                (remove-old-bundle specifier
                                                   (cdr bundle))))))))
    (lambda (bundle-specifier bundle-assoc-list)
      (set! *localization-bundles*
            (cons (cons bundle-specifier bundle-assoc-list)
                  (remove-old-bundle bundle-specifier
                                     *localization-bundles*))))))

;;Retrieve a localized template given its package name and a template name
(define localized-template
  (letrec ((rdc
            (lambda (ls)
              (if (null? (cdr ls))
                  '()
                  (cons (car ls) (rdc (cdr ls))))))
           (find-bundle
            (lambda (specifier template-name)
              (cond ((assoc specifier *localization-bundles*) =>
                     (lambda (bundle) bundle))
                    ((null? specifier) #f)
                    (else (find-bundle (rdc specifier)
                                       template-name))))))
    (lambda (package-name template-name)
      (let loop ((specifier (cons package-name (current-locale))))
        (and (not (null? specifier))
             (let ((bundle (find-bundle specifier template-name)))
               (and bundle
                    (cond ((assq template-name bundle) => cdr)
                          ((null? (cdr specifier)) #f)
                          (else (loop (rdc specifier)))))))))))
</pre>
    <h1>Copyright</h1>
    Copyright (C) Scott G. Miller (2002). All Rights Reserved.  
     
<p> 
      This document and translations of it may be copied and furnished  
      to others, and derivative works that comment on or otherwise explain it
      or assist in its implementation may be prepared, copied, published and
      distributed, in whole or in part, without restriction of any kind, provided
      that the above copyright notice and this paragraph are included on all
      such copies and derivative works. However, this document itself may not
      be modified in any way, such as by removing the copyright notice or references
      to the Scheme Request For Implementation process or editors, except as needed
      for the purpose of developing SRFIs in which case the procedures for copyrights
      defined in the SRFI process must be followed, or as required to translate
      it into languages other than English. </p>
    
    
    <p>
      The limited permissions granted above are perpetual and will not    
      be revoked by the authors or their successors or assigns. </p>
    
    
    <p> 
      This document and the information contained herein is provided on an
      "AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL WARRANTIES, 
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE 
      USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED 
      WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
    </p>
    <hr>                                                                    
    <address>Editor: </address>
    <!-- Created: Tue Sep 29 19:20:08 EDT 1998 --><!-- hhmts start --><!-- hhmts end -->
    Last  modified: Fri Mar 8 17:43:25 PDT 2002       
    
    
  </body>
</html>